# -*- coding: utf-8 -*-
##############################################################################
#    License AGPL-3 - See http://www.gnu.org/licenses/agpl-3.0.html
#    Copyright (C) 2019 Comunitea Servicios Tecnológicos S.L. All Rights Reserved
#    Vicente Ángel Gutiérrez <vicente@comunitea.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

import logging

from odoo import api, fields, models
from PyPDF2 import PdfFileReader, PdfFileMerger, PdfFileWriter
import base64
import io


_logger = logging.getLogger(__name__)

class ReportSignMetadata(models.Model):
    _inherit = "ir.actions.report"

    @api.multi
    def _post_pdf(self, save_in_attachment, pdf_content=None, res_ids=None):

        # if model is stock.batch.picking and has signature_raw_data then we use the modified _post_pdf method
        # otherwise we return the super method

        if self.model == "stock.batch.picking" and self.env[self.model].browse(res_ids).signature_raw_data:
        #if self.model == "stock.batch.picking":

            raw_data_meta = self.env[self.model].browse(res_ids).signature_raw_data

            signature_string = self.env[self.model].browse(res_ids).signature_sig_string

            '''Merge the existing attachments by adding one by one the content of the attachments
            and then, we add the pdf_content if exists. Create the attachments for each record individually
            if required.

            :param save_in_attachment: The retrieved attachments as map record.id -> attachment_id.
            :param pdf_content: The pdf content newly generated by wkhtmltopdf.
            :param res_ids: the ids of record to allow postprocessing.
            :return: The pdf content of the merged pdf.
            '''

            def close_streams(streams):
                for stream in streams:
                    try:
                        stream.close()
                    except Exception:
                        pass

            # Check special case having only one record with existing attachment.
            if len(save_in_attachment) == 1 and not pdf_content:
                return base64.decodestring(list(save_in_attachment.values())[0].datas)

            # Create a list of streams representing all sub-reports part of the final result
            # in order to append the existing attachments and the potentially modified sub-reports
            # by the postprocess_pdf_report calls.
            streams = []

            # In wkhtmltopdf has been called, we need to split the pdf in order to call the postprocess method.
            if pdf_content:
                pdf_content_stream = io.BytesIO(pdf_content)
                # Build a record_map mapping id -> record
                record_map = {r.id: r for r in self.env[self.model].browse([res_id for res_id in res_ids if res_id])}

                # If no value in attachment or no record specified, only append the whole pdf.
                if not record_map or not self.attachment:
                    streams.append(pdf_content_stream)
                else:
                    if len(res_ids) == 1:
                        # Only one record, so postprocess directly and append the whole pdf.
                        if res_ids[0] in record_map and not res_ids[0] in save_in_attachment:
                            self.postprocess_pdf_report(record_map[res_ids[0]], pdf_content_stream)
                        streams.append(pdf_content_stream)
                    else:
                        # In case of multiple docs, we need to split the pdf according the records.
                        # To do so, we split the pdf based on outlines computed by wkhtmltopdf.
                        # An outline is a <h?> html tag found on the document. To retrieve this table,
                        # we look on the pdf structure using pypdf to compute the outlines_pages that is
                        # an array like [0, 3, 5] that means a new document start at page 0, 3 and 5.
                        reader = PdfFileReader(pdf_content_stream)
                        if reader.trailer['/Root'].get('/Dests'):
                            outlines_pages = sorted(
                                [outline.getObject()[0] for outline in reader.trailer['/Root']['/Dests'].values()])
                            assert len(outlines_pages) == len(res_ids)
                            for i, num in enumerate(outlines_pages):
                                to = outlines_pages[i + 1] if i + 1 < len(outlines_pages) else reader.numPages
                                attachment_writer = PdfFileWriter()
                                for j in range(num, to):
                                    attachment_writer.addPage(reader.getPage(j))
                                stream = io.BytesIO()
                                attachment_writer.write(stream)
                                if res_ids[i] and res_ids[i] not in save_in_attachment:
                                    self.postprocess_pdf_report(record_map[res_ids[i]], stream)
                                streams.append(stream)
                            close_streams([pdf_content_stream])
                        else:
                            # If no outlines available, do not save each record
                            streams.append(pdf_content_stream)

            # If attachment_use is checked, the records already having an existing attachment
            # are not been rendered by wkhtmltopdf. So, create a new stream for each of them.
            if self.attachment_use:
                for attachment_id in save_in_attachment.values():
                    content = base64.decodestring(attachment_id.datas)
                    streams.append(io.BytesIO(content))

            # Build the final pdf.
            writer = PdfFileWriter()
            for stream in streams:
                reader = PdfFileReader(stream)
                writer.appendPagesFromReader(reader)
                # We add the metadata
                writer.addMetadata({
                    '/Author': 'LasRias',
                    '/Title': 'PDF With Sign',
                    '/Biometrics': raw_data_meta
                })
            
            result_stream = io.BytesIO()
            streams.append(result_stream)
            writer.write(result_stream)
            result = result_stream.getvalue()

            # We have to close the streams after PdfFileWriter's call to write()
            close_streams(streams)
            return result

        else:
            res = super(ReportSignMetadata, self)._post_pdf(save_in_attachment, pdf_content, res_ids)

            return res